---
title: "start sesh-ing"
author: "Nathan Day"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    message = F,
    warning = F,
  collapse = TRUE,
  comment = "#",
  options(repos="https://cran.rstudio.com" )
)
```

## sesh

Is a light-weigth package manager for R. It sits somewhere between `reprex` and `packrat` and revolves around `CSV` files to save key package information.

```{r load_sesh}
# devtools::install_github("nathancday/sesh")
```

## Purpose

The idea behind `sesh` is being able to share specific package version info with others, including your future self.

## Demo

We start by installoading `forcats` and `tibble` from their current CRAN versions, just so we have some packages beyond R-core.

```{r load_examples}
install.packages("forcats")
install.packages("tibble")

library(forcats)
library(stringr)
devtools::load_all("~/future/sesh/")
```

#### Saving critial packages for your script

`session_info()` is an improvement on `sessionInfo()` for readability, but is still fairly verbose.

`sesh` aims to filter this output to only the attached packages. It also captures information about the current `R-core` version

```{r sesh}
sesh()
```

This dataframe is the essense of `sesh`, a light-weight, easy to share version of your session's info.

While this strategy doesn't cover every NAMESPACE'd load-in, it does cover the major pacakge changes that are the common causes of script breaking.

#### Saving a sesh

To save your current `sesh()` as a CSV use `save_sesh()`.

```{r save_easy, message = T}
save_sesh()
```

The argument `path` uses the `glue` package to paste together R variables, so you can include gloabl variables if properly formatted.

#### Check an old sesh

Now just to show usage, let's re-check the `sesh` we just saved. The function `check_sesh()` with compare your currently installed package versions with a `sesh.csv` specified by the argument `path`.

```{r check_easy, message = T}
check_sesh("sesh_2018-08-18.csv") # check against currently installed versions
```

This just confirms our current session info matches the session info we saved two seconds ago, duh.

#### Simulated time-travel

Let's pretend we are visiting a past script we wrote. So let's install older versions just to mess it up a little and simulate time-travel.

Pretend you are picking up a script that you wrote last year. Scary for sure, but a little less scary, when you let `sesh` take care of the package dependencies.

Here are two common cases: a prior CRAN release version and a package from GitHub at prior commit.

```{r mess_up, message = F}
devtools::install_version("forcats", "0.2.0", reload = F)
devtools::install_github("tidyverse/stringr@bf48d9d64a412dd67f76fc24b7d81a6a6c066105", reload = F)
```

Restart your R session here to reload the newly download version.

```{r force-unload-hidden, echo=F}
unloadNamespace("roxygen2")
```


```{r}
library(forcats)
library(stringr)

sesh()
```


Now re-check our previous session

```{r re-check, message = T}
check_sesh("sesh_2018-08-18.csv")
```

That's cool, `sesh::check_sesh()` shows us the difference between our currently installed packages and the "past" session version.

The function `install_sesh()` will restore matching versions. By looking at the `source` and `version`, it will attempt to install the sesh version in a folder in `~/.Trash/` and let you know if it was succesful.

`sesh` does not touch `.libPaths()`, so it won't intefer with you globally installed package versions. By using `~/.Trash/` as temporary library, `sesh` simply tells itself to load conflicting libraries from there.

```{r install}
install_sesh("sesh_2018-08-18.csv")
```

Great, now you have the the right package versions installed to reproduce your "old" script.

Right now the matching versions are not loaded, we need to call `sesh_load()` for it them to be attached.

The underlying CSV file was added onto by `install_sesh()` and `load_sesh()` looks for those modifications to redirect `lib.loc` to the temporary sesh lib in `~/.Trash`.

```{r}
load_sesh("sesh_2018-08-18.csv")
```

And re-checking we see...

```{r}
check_sesh("sesh_2018-08-18.csv")
```

### Going back

When you are done working with the pacakge version from the past `sesh` you can go back to your global version like this.

In this demo the global versions right now are the back in time version forcats-v0.2.0 and stringr@bf48d9d.

```{r}
unload_sesh("sesh_2018-08-18.csv")

library(forcats)
library(stringr)

sesh()
```

